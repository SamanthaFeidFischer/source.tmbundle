<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>beforeRunningCommand</key>
	<string>nop</string>
	<key>command</key>
	<string>#!/usr/bin/ruby

IS_SELECTION = ENV.key?('TM_SELECTED_TEXT')
CURRENT_LINE = ENV['TM_LINE_NUMBER'].to_i.pred
lines        = STDIN.readlines

# List of operators that determine if a line is or is not an assignment
INCLUDE = %w( -= += /= //= %= *= **= ^= |= &amp;= ||= &amp;&amp;= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= .= x= := ::= =&gt; = )
EXCLUDE = %w( &lt;= &gt;= &lt;=&gt; == === != =~ )

include = Regexp.new(INCLUDE.map { |op| Regexp.escape(op) }.join('|'))
exclude = Regexp.new(EXCLUDE.map { |op| Regexp.escape(op) }.join('|'))

define_method(:matches?) do |line, indent = nil|
  include_match = include.match(line)
  exclude_match = exclude.match(line)
  include_match &amp;&amp; (exclude_match.nil? || include_match.begin(0) &lt; exclude_match.begin(0)) &amp;&amp; (indent.nil? || indent == indent_size(line))
end

# Return the lineâ€™s indent taking tab stops into account
def indent_size(line, tab_size = (ENV['TM_TAB_SIZE'] || '2').to_i)
  size = 0
  $&amp;.scan(/./) do |ch|
    size += ch == ' ' ? 1 : (tab_size - (size % tab_size))
  end if line =~ /^[ \t]*/
  size
end

# This function expects all lines to be assignments and will align them using the split pattern
def align_lines(lines, split_pattern)
  partitioned = lines.map do |line|
    line.partition(split_pattern)
  end

  left_width = partitioned.map { |s, _, _| s.rstrip.size }.max
  op_width   = partitioned.map { |_, s, _| s.size }.max

  partitioned.map do |left, op, right|
    left.rstrip.ljust(left_width+1) + op.rjust(op_width) + right
  end
end

line_numbers = []

if IS_SELECTION
  # Work on all lines that are assignments
  line_numbers = (0..lines.size).select { |i| matches?(lines[i]) }
elsif matches?(lines[CURRENT_LINE])
  # Only work on lines above/below current, as long as they are assignments and have same indent
  first, last, indent = CURRENT_LINE, CURRENT_LINE, indent_size(lines[CURRENT_LINE])
  first -= 1 while first &gt; 0           &amp;&amp; matches?(lines[first-1], indent)
  last  += 1 while last+1 &lt; lines.size &amp;&amp; matches?(lines[last+1], indent)
  line_numbers = (first..last)
end

lines_to_align = line_numbers.map { |i| lines[i] }
aligned_lines  = align_lines(lines_to_align, include)

# Update lines array with our newly aligned lines
line_numbers.each { |i| lines[i] = aligned_lines.shift }

STDOUT &lt;&lt; lines.join
</string>
	<key>input</key>
	<string>selection</string>
	<key>inputFormat</key>
	<string>text</string>
	<key>keyEquivalent</key>
	<string>~@]</string>
	<key>name</key>
	<string>Align Assignments</string>
	<key>outputCaret</key>
	<string>heuristic</string>
	<key>outputFormat</key>
	<string>text</string>
	<key>outputLocation</key>
	<string>replaceInput</string>
	<key>uuid</key>
	<string>FCBE2215-19CA-470A-8D92-BB0D00491D62</string>
	<key>version</key>
	<integer>2</integer>
</dict>
</plist>
